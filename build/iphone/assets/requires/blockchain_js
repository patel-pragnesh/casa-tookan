module.exports=function(){
var self={
basePath:"m/0'/0/",

BITCOIN:0,
ETHEREUM:1},

bitcoin=require("requires/bitcoin"),
ethereum=require("requires/ethereum"),
cache=require("requires/cache"),
network=require("requires/network");































































































































































































































































































return globals.blockchain=self,self.initChains=function(chainId){bitcoin.init(globals.decryptedPassphrase),ethereum.init(globals.decryptedPassphrase)},self.verifyTransaction=function(params){cache.data.chainId==self.BITCOIN?bitcoin.verifyTransaction(params):cache.data.chainId==self.ETHEREUM&&ethereum.verifyTransaction(params)},self.sign=function(tx){if(cache.data.chainId==self.BITCOIN)return bitcoin.sign(tx);if(cache.data.chainId==self.ETHEREUM)return ethereum.sign(tx);throw"chain not supported"},self.getAddress=function(){return cache.data.chainId==self.BITCOIN?bitcoin.getAddress():ethereum.getAddress()},self.signMessage=function(message){return cache.data.chainId==self.BITCOIN?bitcoin.signMessage(message):ethereum.signMessage(message)},self.changeCurrentChain=function(chainId){cache.data.chainId=chainId,self.updateUI(),cache.data.address=chainId==self.BITCOIN?bitcoin.getAddress():ethereum.getAddress(),globals.console.info("Changed: chainId="+chainId+", address="+cache.data.address),cache.save(),void 0!=globals.refreshTokens&&globals.refreshTokens(),void 0!=globals.refreshReceive&&globals.refreshReceive(),void 0!=globals.refreshHistory&&globals.refreshHistory()},self.updateUI=function(){cache.data.chainId==self.BITCOIN?globals.currentColor=globals.bitcoinColor:cache.data.chainId==self.ETHEREUM&&(globals.currentColor=globals.ethereumColor),void 0!=globals.updateTokenUI&&globals.updateTokenUI(),void 0!=globals.updateMenuUI&&globals.updateMenuUI(),void 0!=globals.updateReceiveUI&&globals.updateReceiveUI(),void 0!=globals.updateHistoryUI&&globals.updateHistoryUI(),void 0!=globals.updateDappUI&&globals.updateDappUI(),void 0!=globals.setPage&&globals.setPage(),void 0!=globals.updateDappUI&&globals.updateDappUI()},self.API={},self.API.getBalances=function(params){return"bitcoin"==params.chain?network.connectGET({chain:"btc",version:"v1",method:"addresses/"+bitcoin.getAddressForPath(cache.data.currentPath)+"/balances?page="+params.page+"&per_page="+params.per_page,callback:params.callback,onError:params.onError,always:params.always}):"ethereum"==params.chain?void 0!=params.contractAddress&&"ETH"!=params.contractAddress?network.connectGET({chain:"eth",version:"v1",method:"addresses/"+ethereum.getAddressForPath(cache.data.currentPath)+"/tokens/"+params.contractAddress+"/balance",callback:function(balance){params.callback(balance)},onError:params.onError,always:params.always}):network.connectGET({chain:"eth",version:"v1",method:"addresses/"+cache.data.address+"/balance",callback:function(balance){params.callback(balance)},onError:params.onError,always:params.always}):void 0},self.API.getToken=function(params){return params.chain==self.BITCOIN?network.connectGET({chain:"btc",version:"v1",method:"tokens?name="+params.tokenName,callback:params.callback,onError:params.onError,always:params.always}):params.chain==self.ETHEREUM?network.connectGET({chain:"eth",version:"v1",method:"tokens/"+params.contractAddress,callback:params.callback,onError:params.onError,always:params.always}):void 0},self.API.createSend=function(params){return cache.data.chainId==self.BITCOIN?network.connectPOST({chain:"btc",version:"v1",method:"transactions/send",post:params.post,callback:params.callback,onError:params.onError,always:params.always}):cache.data.chainId==self.ETHEREUM?network.connectPOST({chain:"eth",version:"v1",method:"transactions/send",post:params.post,callback:params.callback,onError:params.onError,always:params.always}):void 0},self.API.estimateGas=function(params){if(cache.data.chainId==self.ETHEREUM)return network.connectPOST({chain:"eth",version:"v1",method:"transactions/estimategas",post:params.post,callback:params.callback,onError:params.onError,always:params.always});throw"chain not supported"},self.getFees=function(params){return cache.data.chainId==self.BITCOIN?network.connectGET({chain:"btc",version:"v1",method:"transactions/estimatefee",callback:params.callback,onError:params.onError,always:params.always}):cache.data.chainId==self.ETHEREUM?network.connectGET({chain:"eth",version:"v1",method:"transactions/gasprice",callback:params.callback,onError:params.onError,always:params.always}):void 0},self.API.broadcast=function(params){return cache.data.chainId==self.BITCOIN?network.connectPOST({chain:"btc",version:"v1",method:"transactions/broadcast",post:{tx:params.signed_tx},callback:params.callback,onError:params.onError,always:params.always}):cache.data.chainId==self.ETHEREUM?network.connectPOST({chain:"eth",version:"v1",method:"transactions/broadcast",post:{tx:params.signed_tx},callback:params.callback,onError:params.onError,always:params.always}):void 0},self.API.getHistory=function(params){return(console.log("addresses/"+cache.data.address+"/history?per_page="+params.per_page+"&page="+params.page),cache.data.chainId==self.BITCOIN)?network.connectGET({chain:"btc",version:"v1",method:"addresses/"+bitcoin.getAddressForPath(cache.data.currentPath)+"/history?per_page="+params.per_page+"&page="+params.page,callback:params.callback,onError:params.onError,always:params.always}):cache.data.chainId==self.ETHEREUM?network.connectGET({chain:"eth",version:"v1",method:"addresses/"+cache.data.address+"/history?per_page="+params.per_page+"&page="+params.page,callback:params.callback,onError:params.onError,always:params.always}):void 0},self;
}();